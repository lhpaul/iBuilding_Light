{
  "name": "matches",
  "version": "0.3.1",
  "author": {
    "name": "Nathan Faubion",
    "email": "nathan@n-son.com"
  },
  "description": "Powerful pattern matching for Javascript",
  "scripts": {
    "test": "mocha -u tdd"
  },
  "main": "./index.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/natefaubion/matches.js.git"
  },
  "keywords": [
    "matching",
    "patterns",
    "pattern",
    "match",
    "functional"
  ],
  "devDependencies": {
    "mocha": "*",
    "adt": "0.3.x",
    "pegjs": "0.7.x",
    "benchmark": "1.0.x",
    "uglify-js": "1.3.x"
  },
  "license": "MIT",
  "readme": "matches.js\n==========\n\nMatches.js brings the power and expressiveness of pattern matching to \nJavascript.\n\nInstall\n-------\n\n`npm install matches`\n\n```js\nvar pattern = require(\"matches\").pattern;\nvar mymap = pattern({\n  '_, []' : function () { \n    return [];\n  },\n  'f, [x, xs...]' : function (f, x, xs) {\n    return [f(x)].concat(mymap(f, xs));\n  }\n});\n\n// [2, 4, 6, 8]\nmymap(function (x) { return x * 2; }, [1, 2, 3, 4]);\n```\n\nPatterns\n--------\n\n### Literals\n\nCheck for specific values using number or string literals, `null`, or \n`undefined`.\n\n```js\nvar myfn = pattern({\n  // Null\n  'null' : function () {...},\n\n  // Undefined\n  'undefined' : function () {...},\n\n  // Numbers\n  '42'    : function () { ... },\n  '12.6'  : function () { ... },\n  '1e+42' : function () { ... },\n\n  // Strings\n  '\"foo\"' : function () { ... },\n\n  // Escape sequences must be double escaped.\n  '\"This string \\\\n matches \\\\n newlines.\"' : function () { ... }\n});\n```\n\n### Wildcards\n\nUnderscores will match successfully on any value but ignore it. A single\nunderscore works well as a catch all pattern.\n\n```js\nvar myfn = pattern({\n  // Match if second argument is 12, ignoring the first\n  '_, 12' : function () { ... },\n\n  // Match on anything\n  '_' : function () { ... }\n});\n```\n\n### Identifiers\n\nPatterns that start with lowercase letters will pass the value to the function.\nValues are passed to the function in the same right to left order they are\ndeclared in the pattern.\n\n```js\nvar myfn = pattern({\n  // Pass on the second argument if the first is 12\n  '12, x': function (x) { ... },\n\n  // Pass on the first and third argument, ignoring the second\n  'x, _, y': function (x, y) { ... }\n});\n```\n\n### Arrays\n\nMatch on the entire array, or only a few values.\n\n```js\nvar myfn = pattern({\n  // Empty array\n  '[]' : function () { ... },\n\n  // Strict comparison on contents\n  '[1, 2, 3]': function () { ... },\n\n  // Grab the first value, ignoring the rest\n  '[x, ...]': function (x) { ... },\n\n  // Split it into a head and tail\n  '[head, tail...]': function (head, tail) { ... },\n\n  // Grab the first and last items, ignoring the middle\n  '[x, ..., y]': function (x, y) { ... },\n\n  // Grab the last item\n  '[..., last]': function (last) { ... },\n\n  // Make a shallow clone\n  '[clone...]': function (clone) { ... },\n\n  // Grab the first item, but also pass on the whole array\n  'arr@[first, ...]': function (arr, first) { ... }\n});\n```\n\n### Objects\n\nLike with an array, you can match on an entire object, or just a few keys.\n\n```js\nvar myfn = pattern({\n  // Empty object\n  '{}': function () { ... },\n\n  // Check that an object has only two keys 'x' and 'y', and pass to the function\n  '{x, y}': function (x, y) { ... },\n\n  // Check that an object has a key 'children' that contains an array\n  '{children: [a, b], ...}': function (a, b) { ... },\n\n  // Match on two keys, 'x' and 'y' and copy the rest to another object\n  '{x: a@Number, y: b@Number, c...}': function (a, b, c) { ... },\n\n  // Make a shallow clone of an object\n  '{clone...}': function (clone) { ... }\n})\n```\n\n### Core Javascript Types\n\nTypecheck arguments using `Number`, `String`, `Date`, `RegExp`, `Function`,\n`Array`, or `Object`.\n\n```js\nvar myfn = pattern({\n  // Takes a function and an array\n  'fn@Function, arr@Array': function (fn, arr) { ... },\n\n  // Takes a function and an object\n  'fn@Function, obj@Object': function (fn, obj) { ... }\n});\n```\n\n### Custom Types\n\nYou can add pattern matching support for your own classes.\n\n```js\n// Create a new class\nfunction MyClass () {\n  this.val = 1;\n}\n\n// Matches.js will check for the non-standard attribute `name` on the constructor\n// function. If you are in the browser and want wider support, or are using\n// anonymous functions, make sure you tag your constructor with `className`.\nMyClass.className = \"MyClass\";\n\n// Add the static method `unapply` for array-like matching.\nMyClass.unapply = function (obj) {\n  return [obj.val];\n};\n\n// Add the static method `unapplyObj` for object-like matching.\nMyClass.unapplyObj = function (obj) {\n  return {\n    'val': obj.val\n  };\n};\n\n// Now you can match on your object.\nvar myfn = pattern({\n  // Type-checking\n  'MyClass': function () { ... },\n\n  // Array-like matching\n  'MyClass(a)': function (a) { ... },\n\n  // Object-like matching\n  'MyClass{val: a}': function (a) { ... }\n});\n```\n\n### Adt.js Types\n\nAdt.js ships with builtin support for matches.js. Adt.js is a library for\nbuilding algebraic data types or case classes in Javascript.\n\n```js\n// Create a new adt.js type\nvar Tree = adt.data({\n  Empty : adt.single(),\n  Node  : adt.record(\"val\", \"left\", \"right\")\n});\n\nvar mytree = Tree.Node(12, Tree.Empty(), Tree.Node(42, Tree.Empty(), Tree.Empty()));\n\nvar myfn = pattern({\n  // Match on an Empty tree node\n  'Empty': function () { ... },\n\n  // Match on a Node with a value of 12\n  'Node(12, ...)': function () { ... },\n\n  // Match using named keys\n  'Node{val: 12, ...}': function () { ... },\n\n  // Match on a Node that has non-Empty children\n  'Node(_, Node, Node)': function () { ... }\n\n  // Match on a Node that has a left child Node of 42 and an Empty right node\n  'Node(val, Node(42, _, _), Empty)': function (val) { ... }\n});\n```\n\nFind out more about adt.js: https://github.com/natefaubion/adt.js\n\nUsage\n-----\n\nMatches.js exports two functions, `pattern` and `caseOf`.\n\n```js\nvar matches = require(\"matches\");\nvar pattern = matches.pattern;\nvar caseOf  = matches.caseOf;\n```\n\n### pattern(patternObj)\n\nThe simplest way is to give it an object with the keys being patterns, and the\nvalues being functions. Each pattern will be tried in order until a match is\nfound.\n\n```js\nvar arrayElems = pattern({\n  '[]': function () { \n    return \"This array is empty.\"; \n  },\n  '[x]': function (x) { \n    return \"This array has one element: \" + x; \n  },\n  '[x, y]': function (x, y) { \n    return \"This array has two elements: \" + x + \" and \" + y;\n  },\n  '[x, y, ...]': function (x, y) {\n    return \"This array is long. The first two elements are: \" + x + \" and \" + y;\n  }\n});\n\narrayElems([1, 2, 3]);\n```\n\n### pattern(patternStr, successFn)\n\nYou can create individual pattern and function pairs.\n\n```js\nvar emptyArray = pattern('[]', function () { return \"Empty array\" });\n\n// \"Empty array\"\nemptyArray([]);\n\n// TypeError: \"All patterns exhausted\"\nemptyArray(12);\n```\n\n### pattern(patternFn, successFn)\n\nYou can also create your own custom pattern functions. The `patternFn` takes\nan array of arguments, and should return `false` for no match, or a new array\nof arguments to forward on to the `successFn`.\n\n```js\nvar greater42 = function (args) {\n  if (args[0] >= 42) return [args[0]];\n  return false;\n};\n\nvar customPattern = pattern(greater42, function (x) {\n  console.log(x);\n});\n\n// Logs 54\ncustomPattern(54);\n\n// TypeError: \"All patterns exhausted\"\ncustomPattern(12);\n```\n\n### caseOf(args..., patternObj)\n\nYou can use `caseOf` to do ad-hoc pattern matching on objects. It's the same\nas immediately invoking a `pattern` function, but lets you put the arguments\nfirst.\n\n```js\nvar result = caseOf(42, {\n  'x@Number' : function (x) { return x * 2; },\n  '_'        : function () { return null; }\n});\n\n// Is the same as...\nvar result = pattern({\n  // ...\n})(42);\n```\n\n### Combinators\n\nYou can combine any of these methods to create unique match chains using the\n`alt` combinator.\n\n```js\n\nvar wildcard = pattern('_', function () { return \"No matches.\"; });\nvar mychain = pattern('1', function () { return \"One\"; })\n  .alt({\n    '2': function () { return \"Two\"; },\n    '3': function () { return \"Three\"; }\n  })\n  .alt(wildcard);\n\n// 'One'\nmychain(1);\n\n// 'Two'\nmychain(2);\n\n// 'No matches.'\nmychain(5);\n```\n\n### Multiple Arguments\n\nSeparate matches for multiple arguments with a comma. Since you can pass any\nnumber of arguments to functions in Javascript, Matches.js is not strict and\nwill happily combine patterns for varying numbers of arguments.\n\n```js\nvar myfn = pattern({\n  // Matches on the first three arguments. If more are passed, they are ignored.\n  '1, \"foo\", [a, ...]': function (a) { return a; },\n\n  // Matches on the first two arguments, ignoring the rest\n  'a, fn@Function': function (a, fn) { return fn(a); },\n\n  // Matches anything\n  '_': function () { return null; }\n});\n\n// 12\nmyfn(6, function (x) { return x * 2; }, \"foo\", \"bar\");\n\n// null\nmyfn(1, 2, 3, 4);\n```\n\n### Performance\n\nPattern strings are compiled to pure Javascript functions and then cached, so\nin general, they are quite fast.\n\nOn a 2GHz core, average compilation time is around .12ms for a pattern\ncomprised of 5-6 sub-patterns. Pattern matched functions are around 3-4x slower\nto dispatch than an equivalent hand-optimized function that does similar\ntype-checking. Keep in mind, that time is measured in the single microseconds \n(1µs vs 3µs) to dispatch 5 calls to the same function.\n",
  "readmeFilename": "README.md",
  "_id": "matches@0.3.1",
  "dist": {
    "shasum": "a4ca0199c1ae962097ff36823bd7ad9f8d830dc9"
  },
  "_from": "matches@0.3.x"
}
