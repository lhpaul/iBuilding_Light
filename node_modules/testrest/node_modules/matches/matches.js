// matches.js
// ----------
// Powerful pattern matching for Javascript
//
// version : 0.3.1
// author  : Nathan Faubion <nathan@n-son.com>
// license : MIT

;(function () {
  function require (path) {
    return require.modules[path];
  }
  require.modules = {};

  require.modules['./parser'] = (function () {
    var module = {exports: {}}, exports = module.exports;
    module.exports = (function(){
      /*
       * Generated by PEG.js 0.7.0.
       *
       * http://pegjs.majda.cz/
       */
      
      function quote(s) {
        /*
         * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
         * string literal except for the closing quote character, backslash,
         * carriage return, line separator, paragraph separator, and line feed.
         * Any character may appear in the form of an escape sequence.
         *
         * For portability, we also escape escape all control and non-ASCII
         * characters. Note that "\0" and "\v" escape sequences are not used
         * because JSHint does not like the first and IE the second.
         */
         return '"' + s
          .replace(/\\/g, '\\\\')  // backslash
          .replace(/"/g, '\\"')    // closing quote character
          .replace(/\x08/g, '\\b') // backspace
          .replace(/\t/g, '\\t')   // horizontal tab
          .replace(/\n/g, '\\n')   // line feed
          .replace(/\f/g, '\\f')   // form feed
          .replace(/\r/g, '\\r')   // carriage return
          .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
          + '"';
      }
      
      var result = {
        /*
         * Parses the input with a generated parser. If the parsing is successfull,
         * returns a value explicitly or implicitly specified by the grammar from
         * which the parser was generated (see |PEG.buildParser|). If the parsing is
         * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
         */
        parse: function(input, startRule) {
          var parseFunctions = {
            "start": parse_start,
            "argumentList": parse_argumentList,
            "array": parse_array,
            "object": parse_object,
            "classArray": parse_classArray,
            "classObject": parse_classObject,
            "capture": parse_capture,
            "keyValue": parse_keyValue,
            "patterns": parse_patterns,
            "pattern": parse_pattern,
            "capturePattern": parse_capturePattern,
            "arrayRestPatterns": parse_arrayRestPatterns,
            "objectRestPatterns": parse_objectRestPatterns,
            "objectPattern": parse_objectPattern,
            "restPattern": parse_restPattern,
            "wildcard": parse_wildcard,
            "identifier": parse_identifier,
            "jsIdentifier": parse_jsIdentifier,
            "restIdentifier": parse_restIdentifier,
            "rest": parse_rest,
            "className": parse_className,
            "key": parse_key,
            "nullLiteral": parse_nullLiteral,
            "undefinedLiteral": parse_undefinedLiteral,
            "booleanLiteral": parse_booleanLiteral,
            "numberLiteral": parse_numberLiteral,
            "stringLiteral": parse_stringLiteral,
            "boolean": parse_boolean,
            "keyChars": parse_keyChars,
            "restChars": parse_restChars,
            "identifierChars": parse_identifierChars,
            "classNameChars": parse_classNameChars,
            "jsIdentifierChars": parse_jsIdentifierChars,
            "string": parse_string,
            "doubleQuotedStringChars": parse_doubleQuotedStringChars,
            "singleQuotedStringChars": parse_singleQuotedStringChars,
            "doubleQuotedStringChar": parse_doubleQuotedStringChar,
            "singleQuotedStringChar": parse_singleQuotedStringChar,
            "escapeSequence": parse_escapeSequence,
            "hexEscapeSequence": parse_hexEscapeSequence,
            "unicodeEscapeSequence": parse_unicodeEscapeSequence,
            "nullEscapeSequence": parse_nullEscapeSequence,
            "charEscapeSequence": parse_charEscapeSequence,
            "singleEscapeChar": parse_singleEscapeChar,
            "nonEscapeChar": parse_nonEscapeChar,
            "escapeChar": parse_escapeChar,
            "sourceChar": parse_sourceChar,
            "number": parse_number,
            "integer": parse_integer,
            "positiveInteger": parse_positiveInteger,
            "negativeInteger": parse_negativeInteger,
            "fraction": parse_fraction,
            "exponent": parse_exponent,
            "eSign": parse_eSign,
            "digitsTenPlus": parse_digitsTenPlus,
            "digits": parse_digits,
            "digitHex": parse_digitHex,
            "digitNoZero": parse_digitNoZero,
            "digit": parse_digit,
            "_": parse__,
            "whitespace": parse_whitespace
          };
          
          if (startRule !== undefined) {
            if (parseFunctions[startRule] === undefined) {
              throw new Error("Invalid rule name: " + quote(startRule) + ".");
            }
          } else {
            startRule = "start";
          }
          
          var pos = 0;
          var reportFailures = 0;
          var rightmostFailuresPos = 0;
          var rightmostFailuresExpected = [];
          
          function padLeft(input, padding, length) {
            var result = input;
            
            var padLength = length - input.length;
            for (var i = 0; i < padLength; i++) {
              result = padding + result;
            }
            
            return result;
          }
          
          function escape(ch) {
            var charCode = ch.charCodeAt(0);
            var escapeChar;
            var length;
            
            if (charCode <= 0xFF) {
              escapeChar = 'x';
              length = 2;
            } else {
              escapeChar = 'u';
              length = 4;
            }
            
            return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
          }
          
          function matchFailed(failure) {
            if (pos < rightmostFailuresPos) {
              return;
            }
            
            if (pos > rightmostFailuresPos) {
              rightmostFailuresPos = pos;
              rightmostFailuresExpected = [];
            }
            
            rightmostFailuresExpected.push(failure);
          }
          
          function parse_start() {
            var result0, result1, result2;
            var pos0, pos1;
            
            pos0 = pos;
            pos1 = pos;
            result0 = parse__();
            if (result0 !== null) {
              result1 = parse_argumentList();
              if (result1 !== null) {
                result2 = parse__();
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, args) {
                  return args;
                })(pos0, result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_argumentList() {
            var result0;
            var pos0;
            
            pos0 = pos;
            result0 = parse_patterns();
            if (result0 !== null) {
              result0 = (function(offset, patterns) {
                  var patStrings = patternStrings(patterns);
                  return {
                    pattern: patStrings.join(","),
                    type: "argumentList",
                    value: patterns
                  };
                })(pos0, result0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_array() {
            var result0, result1, result2, result3, result4;
            var pos0, pos1;
            
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 91) {
              result0 = "[";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"[\"");
              }
            }
            if (result0 !== null) {
              result1 = parse__();
              if (result1 !== null) {
                result2 = parse_arrayRestPatterns();
                result2 = result2 !== null ? result2 : "";
                if (result2 !== null) {
                  result3 = parse__();
                  if (result3 !== null) {
                    if (input.charCodeAt(pos) === 93) {
                      result4 = "]";
                      pos++;
                    } else {
                      result4 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"]\"");
                      }
                    }
                    if (result4 !== null) {
                      result0 = [result0, result1, result2, result3, result4];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, patterns) {
                  patterns || (patterns = []);
                  var patStrings = patternStrings(patterns);
                  var patternStr = "[" + patStrings.join(",") + "]";
                  if (hasMultiRest(patterns)) throwMultRestError(patternStr);
                  return {
                    pattern: patternStr,
                    type: "array",
                    children: patterns
                  };
                })(pos0, result0[2]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_object() {
            var result0, result1, result2, result3, result4;
            var pos0, pos1;
            
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 123) {
              result0 = "{";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"{\"");
              }
            }
            if (result0 !== null) {
              result1 = parse__();
              if (result1 !== null) {
                result2 = parse_objectRestPatterns();
                result2 = result2 !== null ? result2 : "";
                if (result2 !== null) {
                  result3 = parse__();
                  if (result3 !== null) {
                    if (input.charCodeAt(pos) === 125) {
                      result4 = "}";
                      pos++;
                    } else {
                      result4 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"}\"");
                      }
                    }
                    if (result4 !== null) {
                      result0 = [result0, result1, result2, result3, result4];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, patterns) {
                  patterns || (patterns = []);
                  var patStrings = patternStrings(patterns);
                  var patternStr = "{" + patStrings.join(",") + "}";
                  if (hasMultiRest(patterns)) throwMultRestError(patternStr);
                  return {
                    pattern: patternStr,
                    type: "object",
                    children: patterns
                  };
                })(pos0, result0[2]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_classArray() {
            var result0, result1, result2, result3, result4, result5;
            var pos0, pos1;
            
            pos0 = pos;
            pos1 = pos;
            result0 = parse_classNameChars();
            if (result0 !== null) {
              if (input.charCodeAt(pos) === 40) {
                result1 = "(";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"(\"");
                }
              }
              if (result1 !== null) {
                result2 = parse__();
                if (result2 !== null) {
                  result3 = parse_arrayRestPatterns();
                  result3 = result3 !== null ? result3 : "";
                  if (result3 !== null) {
                    result4 = parse__();
                    if (result4 !== null) {
                      if (input.charCodeAt(pos) === 41) {
                        result5 = ")";
                        pos++;
                      } else {
                        result5 = null;
                        if (reportFailures === 0) {
                          matchFailed("\")\"");
                        }
                      }
                      if (result5 !== null) {
                        result0 = [result0, result1, result2, result3, result4, result5];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, name, patterns) {
                  patterns || (patterns = []);
                  var patStrings = patternStrings(patterns);
                  var patternStr = name + "(" + patStrings.join(",") + ")";
                  if (hasMultiRest(patterns)) throwMultRestError(patternStr);
                  return {
                    pattern: patternStr,
                    type: "classArray",
                    value: name,
                    children: patterns
                  };
                })(pos0, result0[0], result0[3]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_classObject() {
            var result0, result1, result2, result3, result4, result5;
            var pos0, pos1;
            
            pos0 = pos;
            pos1 = pos;
            result0 = parse_classNameChars();
            if (result0 !== null) {
              if (input.charCodeAt(pos) === 123) {
                result1 = "{";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"{\"");
                }
              }
              if (result1 !== null) {
                result2 = parse__();
                if (result2 !== null) {
                  result3 = parse_objectRestPatterns();
                  result3 = result3 !== null ? result3 : "";
                  if (result3 !== null) {
                    result4 = parse__();
                    if (result4 !== null) {
                      if (input.charCodeAt(pos) === 125) {
                        result5 = "}";
                        pos++;
                      } else {
                        result5 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"}\"");
                        }
                      }
                      if (result5 !== null) {
                        result0 = [result0, result1, result2, result3, result4, result5];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, name, patterns) {
                  patterns || (patterns = []);
                  var patStrings = patternStrings(patterns);
                  var patternStr = name + "{" + patStrings.join(",") + "}";
                  if (hasMultiRest(patterns)) throwMultRestError(patternStr);
                  return {
                    pattern: patternStr,
                    type: "classObject",
                    value: name,
                    children: patterns
                  };
                })(pos0, result0[0], result0[3]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_capture() {
            var result0, result1, result2, result3, result4;
            var pos0, pos1;
            
            pos0 = pos;
            pos1 = pos;
            result0 = parse_identifierChars();
            if (result0 !== null) {
              result1 = parse__();
              if (result1 !== null) {
                if (input.charCodeAt(pos) === 64) {
                  result2 = "@";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"@\"");
                  }
                }
                if (result2 !== null) {
                  result3 = parse__();
                  if (result3 !== null) {
                    result4 = parse_capturePattern();
                    if (result4 !== null) {
                      result0 = [result0, result1, result2, result3, result4];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, ident, pattern) {
                  return {
                    pattern: ident + "@" + pattern.pattern,
                    type: "capture",
                    value: ident,
                    children: [pattern]
                  };
                })(pos0, result0[0], result0[4]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_keyValue() {
            var result0, result1, result2, result3, result4;
            var pos0, pos1;
            
            pos0 = pos;
            pos1 = pos;
            result0 = parse_keyChars();
            if (result0 !== null) {
              result1 = parse__();
              if (result1 !== null) {
                if (input.charCodeAt(pos) === 58) {
                  result2 = ":";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\":\"");
                  }
                }
                if (result2 !== null) {
                  result3 = parse__();
                  if (result3 !== null) {
                    result4 = parse_pattern();
                    if (result4 !== null) {
                      result0 = [result0, result1, result2, result3, result4];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, key, pattern) {
                  return {
                    pattern: quote(key) + ":" + pattern.pattern,
                    type: "keyValue",
                    value: quote(key),
                    children: [pattern]
                  };
                })(pos0, result0[0], result0[4]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_patterns() {
            var result0, result1, result2, result3, result4, result5;
            var pos0, pos1, pos2;
            
            pos0 = pos;
            pos1 = pos;
            result0 = parse_pattern();
            if (result0 !== null) {
              result1 = [];
              pos2 = pos;
              result2 = parse__();
              if (result2 !== null) {
                if (input.charCodeAt(pos) === 44) {
                  result3 = ",";
                  pos++;
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (result3 !== null) {
                  result4 = parse__();
                  if (result4 !== null) {
                    result5 = parse_pattern();
                    if (result5 !== null) {
                      result2 = [result2, result3, result4, result5];
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
              while (result2 !== null) {
                result1.push(result2);
                pos2 = pos;
                result2 = parse__();
                if (result2 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    result3 = ",";
                    pos++;
                  } else {
                    result3 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (result3 !== null) {
                    result4 = parse__();
                    if (result4 !== null) {
                      result5 = parse_pattern();
                      if (result5 !== null) {
                        result2 = [result2, result3, result4, result5];
                      } else {
                        result2 = null;
                        pos = pos2;
                      }
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              }
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, head, tail) {
                  return headTailMerge(head, tail, 3);
                })(pos0, result0[0], result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_pattern() {
            var result0;
            
            result0 = parse_wildcard();
            if (result0 === null) {
              result0 = parse_nullLiteral();
              if (result0 === null) {
                result0 = parse_undefinedLiteral();
                if (result0 === null) {
                  result0 = parse_booleanLiteral();
                  if (result0 === null) {
                    result0 = parse_numberLiteral();
                    if (result0 === null) {
                      result0 = parse_stringLiteral();
                      if (result0 === null) {
                        result0 = parse_classArray();
                        if (result0 === null) {
                          result0 = parse_classObject();
                          if (result0 === null) {
                            result0 = parse_className();
                            if (result0 === null) {
                              result0 = parse_array();
                              if (result0 === null) {
                                result0 = parse_object();
                                if (result0 === null) {
                                  result0 = parse_capture();
                                  if (result0 === null) {
                                    result0 = parse_identifier();
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            return result0;
          }
          
          function parse_capturePattern() {
            var result0;
            
            result0 = parse_classArray();
            if (result0 === null) {
              result0 = parse_classObject();
              if (result0 === null) {
                result0 = parse_className();
                if (result0 === null) {
                  result0 = parse_array();
                  if (result0 === null) {
                    result0 = parse_object();
                  }
                }
              }
            }
            return result0;
          }
          
          function parse_arrayRestPatterns() {
            var result0, result1, result2, result3, result4, result5;
            var pos0, pos1, pos2;
            
            pos0 = pos;
            pos1 = pos;
            result0 = parse_restPattern();
            if (result0 === null) {
              result0 = parse_pattern();
            }
            if (result0 !== null) {
              result1 = [];
              pos2 = pos;
              result2 = parse__();
              if (result2 !== null) {
                if (input.charCodeAt(pos) === 44) {
                  result3 = ",";
                  pos++;
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (result3 !== null) {
                  result4 = parse__();
                  if (result4 !== null) {
                    result5 = parse_restPattern();
                    if (result5 === null) {
                      result5 = parse_pattern();
                    }
                    if (result5 !== null) {
                      result2 = [result2, result3, result4, result5];
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
              while (result2 !== null) {
                result1.push(result2);
                pos2 = pos;
                result2 = parse__();
                if (result2 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    result3 = ",";
                    pos++;
                  } else {
                    result3 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (result3 !== null) {
                    result4 = parse__();
                    if (result4 !== null) {
                      result5 = parse_restPattern();
                      if (result5 === null) {
                        result5 = parse_pattern();
                      }
                      if (result5 !== null) {
                        result2 = [result2, result3, result4, result5];
                      } else {
                        result2 = null;
                        pos = pos2;
                      }
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              }
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, head, tail) {
                  return headTailMerge(head, tail, 3);
                })(pos0, result0[0], result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_objectRestPatterns() {
            var result0, result1, result2, result3, result4, result5;
            var pos0, pos1, pos2;
            
            pos0 = pos;
            pos1 = pos;
            result0 = parse_restPattern();
            if (result0 === null) {
              result0 = parse_objectPattern();
            }
            if (result0 !== null) {
              result1 = [];
              pos2 = pos;
              result2 = parse__();
              if (result2 !== null) {
                if (input.charCodeAt(pos) === 44) {
                  result3 = ",";
                  pos++;
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (result3 !== null) {
                  result4 = parse__();
                  if (result4 !== null) {
                    result5 = parse_restPattern();
                    if (result5 === null) {
                      result5 = parse_objectPattern();
                    }
                    if (result5 !== null) {
                      result2 = [result2, result3, result4, result5];
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
              while (result2 !== null) {
                result1.push(result2);
                pos2 = pos;
                result2 = parse__();
                if (result2 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    result3 = ",";
                    pos++;
                  } else {
                    result3 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (result3 !== null) {
                    result4 = parse__();
                    if (result4 !== null) {
                      result5 = parse_restPattern();
                      if (result5 === null) {
                        result5 = parse_objectPattern();
                      }
                      if (result5 !== null) {
                        result2 = [result2, result3, result4, result5];
                      } else {
                        result2 = null;
                        pos = pos2;
                      }
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              }
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, head, tail) {
                  return headTailMerge(head, tail, 3);
                })(pos0, result0[0], result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_objectPattern() {
            var result0;
            
            result0 = parse_keyValue();
            if (result0 === null) {
              result0 = parse_key();
            }
            return result0;
          }
          
          function parse_restPattern() {
            var result0;
            
            result0 = parse_restIdentifier();
            if (result0 === null) {
              result0 = parse_rest();
            }
            return result0;
          }
          
          function parse_wildcard() {
            var result0;
            var pos0;
            
            pos0 = pos;
            if (input.charCodeAt(pos) === 95) {
              result0 = "_";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"_\"");
              }
            }
            if (result0 !== null) {
              result0 = (function(offset) {
                  return {
                    pattern: "_",
                    type: "wildcard"
                  };
                })(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_identifier() {
            var result0;
            var pos0;
            
            pos0 = pos;
            result0 = parse_identifierChars();
            if (result0 !== null) {
              result0 = (function(offset, ident) {
                  return {
                    pattern: ident,
                    type: "identifier",
                    value: ident
                  };
                })(pos0, result0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_jsIdentifier() {
            var result0;
            var pos0;
            
            pos0 = pos;
            result0 = parse_jsIdentifierChars();
            if (result0 !== null) {
              result0 = (function(offset, ident) {
                  return {
                    pattern: ident,
                    type: "jsIdentifier",
                    value: ident
                  };
                })(pos0, result0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_restIdentifier() {
            var result0, result1;
            var pos0, pos1;
            
            pos0 = pos;
            pos1 = pos;
            result0 = parse_identifierChars();
            if (result0 !== null) {
              result1 = parse_restChars();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, ident) {
                  return {
                    pattern: ident + "...",
                    type: "restIdentifier",
                    value: ident
                  };
                })(pos0, result0[0]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_rest() {
            var result0;
            var pos0;
            
            pos0 = pos;
            result0 = parse_restChars();
            if (result0 !== null) {
              result0 = (function(offset) {
                  return {
                    pattern: "...",
                    type: "rest"
                  };
                })(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_className() {
            var result0;
            var pos0;
            
            pos0 = pos;
            result0 = parse_classNameChars();
            if (result0 !== null) {
              result0 = (function(offset, name) {
                  return {
                    pattern: name,
                    type: "className",
                    value: name
                  };
                })(pos0, result0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_key() {
            var result0;
            var pos0;
            
            pos0 = pos;
            result0 = parse_keyChars();
            if (result0 !== null) {
              result0 = (function(offset, key) {
                  return {
                    pattern: quote(key),
                    type: "key",
                    value: quote(key)
                  };
                })(pos0, result0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_nullLiteral() {
            var result0;
            var pos0;
            
            pos0 = pos;
            if (input.substr(pos, 4) === "null") {
              result0 = "null";
              pos += 4;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"null\"");
              }
            }
            if (result0 !== null) {
              result0 = (function(offset) {
                  return {
                    pattern: "null",
                    type: "null"
                  };
                })(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_undefinedLiteral() {
            var result0;
            var pos0;
            
            pos0 = pos;
            if (input.substr(pos, 9) === "undefined") {
              result0 = "undefined";
              pos += 9;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"undefined\"");
              }
            }
            if (result0 !== null) {
              result0 = (function(offset) {
                  return {
                    pattern: "undefined",
                    type: "undefined"
                  };
                })(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_booleanLiteral() {
            var result0;
            var pos0;
            
            pos0 = pos;
            result0 = parse_boolean();
            if (result0 !== null) {
              result0 = (function(offset, bool) {
                  return {
                    pattern: bool,
                    type: "boolean",
                    value: bool === "true"
                  }
                })(pos0, result0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_numberLiteral() {
            var result0;
            var pos0;
            
            pos0 = pos;
            result0 = parse_number();
            if (result0 !== null) {
              result0 = (function(offset, num) {
                  return {
                    pattern: num,
                    type: "number",
                    value: parseFloat(num)
                  };
                })(pos0, result0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_stringLiteral() {
            var result0;
            var pos0;
            
            pos0 = pos;
            result0 = parse_string();
            if (result0 !== null) {
              result0 = (function(offset, str) {
                  return {
                    pattern: quote(str),
                    type: "string",
                    value: str
                  }
                })(pos0, result0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_boolean() {
            var result0;
            
            if (input.substr(pos, 4) === "true") {
              result0 = "true";
              pos += 4;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"true\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 5) === "false") {
                result0 = "false";
                pos += 5;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"false\"");
                }
              }
            }
            return result0;
          }
          
          function parse_keyChars() {
            var result0;
            
            result0 = parse_jsIdentifierChars();
            if (result0 === null) {
              result0 = parse_string();
            }
            return result0;
          }
          
          function parse_restChars() {
            var result0;
            
            if (input.substr(pos, 3) === "...") {
              result0 = "...";
              pos += 3;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"...\"");
              }
            }
            return result0;
          }
          
          function parse_identifierChars() {
            var result0, result1, result2;
            var pos0, pos1;
            
            reportFailures++;
            pos0 = pos;
            pos1 = pos;
            if (/^[a-z]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[a-z]");
              }
            }
            if (result0 !== null) {
              result1 = [];
              if (/^[_$a-zA-Z0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[_$a-zA-Z0-9]");
                }
              }
              while (result2 !== null) {
                result1.push(result2);
                if (/^[_$a-zA-Z0-9]/.test(input.charAt(pos))) {
                  result2 = input.charAt(pos);
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("[_$a-zA-Z0-9]");
                  }
                }
              }
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, head, tail) {
                  return head + tail.join("");
                })(pos0, result0[0], result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            reportFailures--;
            if (reportFailures === 0 && result0 === null) {
              matchFailed("identifier");
            }
            return result0;
          }
          
          function parse_classNameChars() {
            var result0, result1, result2;
            var pos0, pos1;
            
            reportFailures++;
            pos0 = pos;
            pos1 = pos;
            if (/^[A-Z]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[A-Z]");
              }
            }
            if (result0 !== null) {
              result1 = [];
              if (/^[_$a-zA-Z0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[_$a-zA-Z0-9]");
                }
              }
              while (result2 !== null) {
                result1.push(result2);
                if (/^[_$a-zA-Z0-9]/.test(input.charAt(pos))) {
                  result2 = input.charAt(pos);
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("[_$a-zA-Z0-9]");
                  }
                }
              }
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, head, tail) {
                  return head + tail.join("");
                })(pos0, result0[0], result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            reportFailures--;
            if (reportFailures === 0 && result0 === null) {
              matchFailed("class name");
            }
            return result0;
          }
          
          function parse_jsIdentifierChars() {
            var result0, result1, result2;
            var pos0, pos1;
            
            reportFailures++;
            pos0 = pos;
            pos1 = pos;
            if (/^[_$a-zA-Z]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[_$a-zA-Z]");
              }
            }
            if (result0 !== null) {
              result1 = [];
              if (/^[_$a-zA-Z0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[_$a-zA-Z0-9]");
                }
              }
              while (result2 !== null) {
                result1.push(result2);
                if (/^[_$a-zA-Z0-9]/.test(input.charAt(pos))) {
                  result2 = input.charAt(pos);
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("[_$a-zA-Z0-9]");
                  }
                }
              }
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, head, tail) {
                  return head + tail.join("");
                })(pos0, result0[0], result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            reportFailures--;
            if (reportFailures === 0 && result0 === null) {
              matchFailed("Javascript identifier");
            }
            return result0;
          }
          
          function parse_string() {
            var result0, result1, result2;
            var pos0, pos1;
            
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 34) {
              result0 = "\"";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\"\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_doubleQuotedStringChars();
              result1 = result1 !== null ? result1 : "";
              if (result1 !== null) {
                if (input.charCodeAt(pos) === 34) {
                  result2 = "\"";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\\"\"");
                  }
                }
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 === null) {
              pos1 = pos;
              if (input.charCodeAt(pos) === 39) {
                result0 = "'";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"'\"");
                }
              }
              if (result0 !== null) {
                result1 = parse_singleQuotedStringChars();
                result1 = result1 !== null ? result1 : "";
                if (result1 !== null) {
                  if (input.charCodeAt(pos) === 39) {
                    result2 = "'";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"'\"");
                    }
                  }
                  if (result2 !== null) {
                    result0 = [result0, result1, result2];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            }
            if (result0 !== null) {
              result0 = (function(offset, parts) {
                  return parts[1];
                })(pos0, result0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_doubleQuotedStringChars() {
            var result0, result1;
            var pos0;
            
            pos0 = pos;
            result1 = parse_doubleQuotedStringChar();
            if (result1 !== null) {
              result0 = [];
              while (result1 !== null) {
                result0.push(result1);
                result1 = parse_doubleQuotedStringChar();
              }
            } else {
              result0 = null;
            }
            if (result0 !== null) {
              result0 = (function(offset, chars) {
                  return chars.join("");
                })(pos0, result0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_singleQuotedStringChars() {
            var result0, result1;
            var pos0;
            
            pos0 = pos;
            result1 = parse_singleQuotedStringChar();
            if (result1 !== null) {
              result0 = [];
              while (result1 !== null) {
                result0.push(result1);
                result1 = parse_singleQuotedStringChar();
              }
            } else {
              result0 = null;
            }
            if (result0 !== null) {
              result0 = (function(offset, chars) {
                  return chars.join("");
                })(pos0, result0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_doubleQuotedStringChar() {
            var result0, result1;
            var pos0, pos1, pos2;
            
            pos0 = pos;
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            if (input.charCodeAt(pos) === 34) {
              result0 = "\"";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\"\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 92) {
                result0 = "\\";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\\\"");
                }
              }
            }
            reportFailures--;
            if (result0 === null) {
              result0 = "";
            } else {
              result0 = null;
              pos = pos2;
            }
            if (result0 !== null) {
              result1 = parse_sourceChar();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, char_) {
                  return char_;
                })(pos0, result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              if (input.charCodeAt(pos) === 92) {
                result0 = "\\";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\\\"");
                }
              }
              if (result0 !== null) {
                result1 = parse_escapeSequence();
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = (function(offset, seq) {
                    return seq;
                  })(pos0, result0[1]);
              }
              if (result0 === null) {
                pos = pos0;
              }
            }
            return result0;
          }
          
          function parse_singleQuotedStringChar() {
            var result0, result1;
            var pos0, pos1, pos2;
            
            pos0 = pos;
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            if (input.charCodeAt(pos) === 39) {
              result0 = "'";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"'\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 92) {
                result0 = "\\";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\\\"");
                }
              }
            }
            reportFailures--;
            if (result0 === null) {
              result0 = "";
            } else {
              result0 = null;
              pos = pos2;
            }
            if (result0 !== null) {
              result1 = parse_sourceChar();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, char_) {
                  return char_;
                })(pos0, result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              if (input.charCodeAt(pos) === 92) {
                result0 = "\\";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\\\"");
                }
              }
              if (result0 !== null) {
                result1 = parse_escapeSequence();
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = (function(offset, seq) {
                    return seq;
                  })(pos0, result0[1]);
              }
              if (result0 === null) {
                pos = pos0;
              }
            }
            return result0;
          }
          
          function parse_escapeSequence() {
            var result0;
            
            result0 = parse_charEscapeSequence();
            if (result0 === null) {
              result0 = parse_nullEscapeSequence();
              if (result0 === null) {
                result0 = parse_hexEscapeSequence();
                if (result0 === null) {
                  result0 = parse_unicodeEscapeSequence();
                }
              }
            }
            return result0;
          }
          
          function parse_hexEscapeSequence() {
            var result0, result1, result2;
            var pos0, pos1;
            
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 120) {
              result0 = "x";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"x\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_digitHex();
              if (result1 !== null) {
                result2 = parse_digitHex();
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, h1, h2) {
                  return String.fromCharCode(parseInt("0x" + h1 + h2));
                })(pos0, result0[1], result0[2]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_unicodeEscapeSequence() {
            var result0, result1, result2, result3, result4;
            var pos0, pos1;
            
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 117) {
              result0 = "u";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"u\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_digitHex();
              if (result1 !== null) {
                result2 = parse_digitHex();
                if (result2 !== null) {
                  result3 = parse_digitHex();
                  if (result3 !== null) {
                    result4 = parse_digitHex();
                    if (result4 !== null) {
                      result0 = [result0, result1, result2, result3, result4];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, h1, h2, h3, h4) {
                  return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
                })(pos0, result0[1], result0[2], result0[3], result0[4]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_nullEscapeSequence() {
            var result0, result1;
            var pos0, pos1, pos2;
            
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 48) {
              result0 = "0";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"0\"");
              }
            }
            if (result0 !== null) {
              pos2 = pos;
              reportFailures++;
              result1 = parse_digit();
              reportFailures--;
              if (result1 === null) {
                result1 = "";
              } else {
                result1 = null;
                pos = pos2;
              }
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset) {
                  return "\0";
                })(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_charEscapeSequence() {
            var result0;
            
            result0 = parse_singleEscapeChar();
            if (result0 === null) {
              result0 = parse_nonEscapeChar();
            }
            return result0;
          }
          
          function parse_singleEscapeChar() {
            var result0;
            var pos0;
            
            pos0 = pos;
            if (/^['"\\bfnrtv]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("['\"\\\\bfnrtv]");
              }
            }
            if (result0 !== null) {
              result0 = (function(offset, char_) {
                  return char_
                    .replace("b", "\b")
                    .replace("f", "\f")
                    .replace("n", "\n")
                    .replace("r", "\r")
                    .replace("t", "\t")
                    .replace("v", "\x0B");
                })(pos0, result0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_nonEscapeChar() {
            var result0, result1;
            var pos0, pos1, pos2;
            
            pos0 = pos;
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            result0 = parse_escapeChar();
            reportFailures--;
            if (result0 === null) {
              result0 = "";
            } else {
              result0 = null;
              pos = pos2;
            }
            if (result0 !== null) {
              result1 = parse_sourceChar();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, char_) {
                  return char_;
                })(pos0, result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_escapeChar() {
            var result0;
            
            result0 = parse_singleEscapeChar();
            if (result0 === null) {
              result0 = parse_digit();
              if (result0 === null) {
                if (input.charCodeAt(pos) === 120) {
                  result0 = "x";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"x\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 117) {
                    result0 = "u";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"u\"");
                    }
                  }
                }
              }
            }
            return result0;
          }
          
          function parse_sourceChar() {
            var result0;
            
            if (input.length > pos) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            return result0;
          }
          
          function parse_number() {
            var result0, result1, result2;
            var pos0, pos1;
            
            pos0 = pos;
            pos1 = pos;
            result0 = parse_integer();
            if (result0 !== null) {
              result1 = parse_fraction();
              if (result1 !== null) {
                result2 = parse_exponent();
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, int_, frac, exp) {
                  return int_ + frac + exp;
                })(pos0, result0[0], result0[1], result0[2]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              result0 = parse_integer();
              if (result0 !== null) {
                result1 = parse_fraction();
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = (function(offset, int_, frac) {
                    return int_ + frac;
                  })(pos0, result0[0], result0[1]);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                pos1 = pos;
                result0 = parse_integer();
                if (result0 !== null) {
                  result1 = parse_exponent();
                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
                if (result0 !== null) {
                  result0 = (function(offset, int_, exp) {
                      return int_ + exp;
                    })(pos0, result0[0], result0[1]);
                }
                if (result0 === null) {
                  pos = pos0;
                }
                if (result0 === null) {
                  result0 = parse_integer();
                }
              }
            }
            return result0;
          }
          
          function parse_integer() {
            var result0;
            
            result0 = parse_positiveInteger();
            if (result0 === null) {
              result0 = parse_negativeInteger();
            }
            return result0;
          }
          
          function parse_positiveInteger() {
            var result0;
            
            result0 = parse_digitsTenPlus();
            if (result0 === null) {
              result0 = parse_digit();
            }
            return result0;
          }
          
          function parse_negativeInteger() {
            var result0, result1;
            var pos0, pos1;
            
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 45) {
              result0 = "-";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"-\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_digitsTenPlus();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, digits) {
                  return "-" + digits;
                })(pos0, result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              if (input.charCodeAt(pos) === 45) {
                result0 = "-";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result0 !== null) {
                result1 = parse_digit();
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = (function(offset, digit) {
                    return "-" + digit;
                  })(pos0, result0[1]);
              }
              if (result0 === null) {
                pos = pos0;
              }
            }
            return result0;
          }
          
          function parse_fraction() {
            var result0, result1;
            var pos0, pos1;
            
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 46) {
              result0 = ".";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_digits();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, digits) {
                  return "." + digits;
                })(pos0, result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_exponent() {
            var result0, result1;
            var pos0, pos1;
            
            pos0 = pos;
            pos1 = pos;
            result0 = parse_eSign();
            if (result0 !== null) {
              result1 = parse_digits();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, e, digits) {
                  return e + digits;
                })(pos0, result0[0], result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_eSign() {
            var result0, result1;
            var pos0, pos1;
            
            pos0 = pos;
            pos1 = pos;
            if (/^[eE]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[eE]");
              }
            }
            if (result0 !== null) {
              if (/^[+\-]/.test(input.charAt(pos))) {
                result1 = input.charAt(pos);
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("[+\\-]");
                }
              }
              result1 = result1 !== null ? result1 : "";
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, e, sign) {
                  return e + sign;
                })(pos0, result0[0], result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_digitsTenPlus() {
            var result0, result1;
            var pos0, pos1;
            
            pos0 = pos;
            pos1 = pos;
            result0 = parse_digitNoZero();
            if (result0 !== null) {
              result1 = parse_digits();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, digit, digits) {
                  return digit + digits;
                })(pos0, result0[0], result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_digits() {
            var result0, result1;
            var pos0;
            
            pos0 = pos;
            result1 = parse_digit();
            if (result1 !== null) {
              result0 = [];
              while (result1 !== null) {
                result0.push(result1);
                result1 = parse_digit();
              }
            } else {
              result0 = null;
            }
            if (result0 !== null) {
              result0 = (function(offset, digits) {
                  return digits.join("");
                })(pos0, result0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            return result0;
          }
          
          function parse_digitHex() {
            var result0;
            
            if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9a-fA-F]");
              }
            }
            return result0;
          }
          
          function parse_digitNoZero() {
            var result0;
            
            if (/^[1-9]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[1-9]");
              }
            }
            return result0;
          }
          
          function parse_digit() {
            var result0;
            
            if (/^[0-9]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            return result0;
          }
          
          function parse__() {
            var result0, result1;
            
            result0 = [];
            result1 = parse_whitespace();
            while (result1 !== null) {
              result0.push(result1);
              result1 = parse_whitespace();
            }
            return result0;
          }
          
          function parse_whitespace() {
            var result0;
            
            if (input.charCodeAt(pos) === 32) {
              result0 = " ";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\" \"");
              }
            }
            return result0;
          }
          
          
          function cleanupExpected(expected) {
            expected.sort();
            
            var lastExpected = null;
            var cleanExpected = [];
            for (var i = 0; i < expected.length; i++) {
              if (expected[i] !== lastExpected) {
                cleanExpected.push(expected[i]);
                lastExpected = expected[i];
              }
            }
            return cleanExpected;
          }
          
          function computeErrorPosition() {
            /*
             * The first idea was to use |String.split| to break the input up to the
             * error position along newlines and derive the line and column from
             * there. However IE's |split| implementation is so broken that it was
             * enough to prevent it.
             */
            
            var line = 1;
            var column = 1;
            var seenCR = false;
            
            for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
              var ch = input.charAt(i);
              if (ch === "\n") {
                if (!seenCR) { line++; }
                column = 1;
                seenCR = false;
              } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                line++;
                column = 1;
                seenCR = true;
              } else {
                column++;
                seenCR = false;
              }
            }
            
            return { line: line, column: column };
          }
          
          
            // Merges a head token and tail tokens into a single list. The tail tokens
            // usually contain commas and whitespace, so the index is required to extract
            // the correct token from the tail.
            function headTailMerge (head, tail, index) {
              var result = [head];
              for (var i = 0; i < tail.length; i++) {
                result.push(tail[i][index])
              }
              return result;
            }
          
            // Checks for multiple rest tokens within a list of patterns.
            function hasMultiRest (patterns) {
              for (var i = 0, count = 0, pat; (pat = patterns[i]); i++) {
                if (pat.type === "rest" || pat.type === "restIdentifier") count += 1;
                if (count > 1) return true;
              }
              return false;
            }
          
            // Returns all pattern strings of a list of children
            function patternStrings (children) {
              return children.map(function (child) {
                return child.pattern;
              });
            }
          
            function throwMultRestError (patternStr) {
              throw new SyntaxError("Multiple rest paramaters are not allowed in sub-pattern " + patternStr);
            }
          
          
          var result = parseFunctions[startRule]();
          
          /*
           * The parser is now in one of the following three states:
           *
           * 1. The parser successfully parsed the whole input.
           *
           *    - |result !== null|
           *    - |pos === input.length|
           *    - |rightmostFailuresExpected| may or may not contain something
           *
           * 2. The parser successfully parsed only a part of the input.
           *
           *    - |result !== null|
           *    - |pos < input.length|
           *    - |rightmostFailuresExpected| may or may not contain something
           *
           * 3. The parser did not successfully parse any part of the input.
           *
           *   - |result === null|
           *   - |pos === 0|
           *   - |rightmostFailuresExpected| contains at least one failure
           *
           * All code following this comment (including called functions) must
           * handle these states.
           */
          if (result === null || pos !== input.length) {
            var offset = Math.max(pos, rightmostFailuresPos);
            var found = offset < input.length ? input.charAt(offset) : null;
            var errorPosition = computeErrorPosition();
            
            throw new this.SyntaxError(
              cleanupExpected(rightmostFailuresExpected),
              found,
              offset,
              errorPosition.line,
              errorPosition.column
            );
          }
          
          return result;
        },
        
        /* Returns the parser source code. */
        toSource: function() { return this._source; }
      };
      
      /* Thrown when a parser encounters a syntax error. */
      
      result.SyntaxError = function(expected, found, offset, line, column) {
        function buildMessage(expected, found) {
          var expectedHumanized, foundHumanized;
          
          switch (expected.length) {
            case 0:
              expectedHumanized = "end of input";
              break;
            case 1:
              expectedHumanized = expected[0];
              break;
            default:
              expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
                + " or "
                + expected[expected.length - 1];
          }
          
          foundHumanized = found ? quote(found) : "end of input";
          
          return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
        }
        
        this.name = "SyntaxError";
        this.expected = expected;
        this.found = found;
        this.message = buildMessage(expected, found);
        this.offset = offset;
        this.line = line;
        this.column = column;
      };
      
      result.SyntaxError.prototype = Error.prototype;
      
      return result;
    })();
    return module.exports;
  })();

  require.modules['./compiler'] = (function () {
    var module = {exports: {}}, exports = module.exports;
    // Compiles a new pattern matching function given a syntax tree.
    function compile (tree) {
      var source = [
        "var ret = [];",
        compileArgumentList(tree),
        "return ret;"
      ];
    
      return new Function(["args", "runt"], source.join("\n"));
    }
    
    // Export
    exports.compile = compile;
    
    // Mapping of tokens to compiler functions
    var compilers = {
      "wildcard"    : compileWildcard,
      "null"        : compileNull,
      "undefined"   : compileUndefined,
      "boolean"     : compileBoolean,
      "number"      : compileNumber,
      "string"      : compileString,
      "identifier"  : compileIdentifier,
      "array"       : compileArray,
      "object"      : compileObject,
      "classArray"  : compileClassArray,
      "classObject" : compileClassObject,
      "className"   : compileClassName,
      "capture"     : compileCapture
    };
    
    
    // Compiler Functions
    // ------------------
    
    function compileArgumentList (node) {
      var source = [];
      for (var i = 0, len = node.value.length, argName; i < len; i++) {
        argName = "arg_" + i;
        source.push(
          "var " + argName + " = args[" + i + "];",
          compilePattern(argName, node.value[i])
        );
      }
      return source.join("\n");
    }
    
    function compilePattern (argName, node) {
      return compilers[node.type](argName, node);
    }
    
    function compileWildcard () {
      // Wildcards don't perform any matching or stash any values, so just return
      // an empty string.
      return "";
    }
    
    function compileNull (argName) {
      return "if (" + argName + " !== null) return false;";
    }
    
    function compileUndefined (argName) {
      return "if (" + argName + " !== void 0) return false;";
    }
    
    function compileBoolean (argName, node) {
      return "if (" + argName + " !== " + node.pattern + ") return false;";
    }
    
    function compileNumber (argName, node) {
      return "if (" + argName + " !== " + node.pattern + ") return false;";
    }
    
    function compileString (argName, node) {
      return "if (" + argName + " !== " + node.pattern + ") return false;";
    }
    
    function compileIdentifier (argName) {
      return "ret.push(" + argName + ");";
    }
    
    function compileClassName (argName, node) {
      return "if (!runt.matchesTypeName(" + argName + ", '" + node.value + "')) return false;"
    }
    
    function compileCapture (argName, node) {
      var source = [
        "ret.push(" + argName + ");",
        compilePattern(argName, node.children[0])
      ];
    
      return source.join("\n");
    }
    
    function hasRest (node) {
      for (var i = 0, child; (child = node.children[i]); i++) {
        if (child.type === "rest" || child.type === "restIdentifier") return true;
      }
      return false;
    }
    
    function compileArray (argName, node) {
      return hasRest(node)
        ? compileArrayRest(argName, node)
        : compileArrayStrict(argName, node);
    }
    
    function compileArrayStrict (argName, node) {
      var arrLen = node.children.length;
      var source = [
        "if (!(" + argName + " instanceof Array) || " + 
        argName + ".length !== " + arrLen + ") return false;"
      ];
    
      node.children.forEach(function (child, i) {
        var childArgName = argName + "_" + i;
        source.push(
          "var " + childArgName + " = " + argName + "[" + i + "];",
          compilePattern(childArgName, child)
        );
      });
    
      return source.join("\n");
    }
    
    function compileArrayRest (argName, node) {
      var arrLen = node.children.length;
      var minLen = arrLen - 1;
    
      // Used for calculating the slice position
      var posName = argName + "_pos";
    
      var source = [
        "if (!(" + argName + " instanceof Array) || " + 
          argName + ".length < " + minLen + ") return false;",
        "var " + posName + " = 0;"
      ];
    
      node.children.forEach(function (child, i) {
        var childArgName = argName + "_" + i;
        var isRestIdent = child.type === "restIdentifier";
    
        // If the current child is a rest token, perform the appropriate slicing
        // and stashing. Different slices are used depending on whether the token
        // is in the middle of the child patterns or at the end.
        if (isRestIdent || child.type === "rest") {
          // Rest is at the end. This only matters if the rest needs to be stashed,
          // otherwise it can be ignored.
          if (i === minLen && isRestIdent) {
            source.push("ret.push(" + argName + ".slice(" + i + "));");
          }
          // Rest is at the beginning.
          else if (i === 0) {
            source.push(posName + " = " + argName + ".length - " + minLen + ";")
            if (isRestIdent) source.push("ret.push(" + argName + ".slice(0, " + posName + "));");
          }
          // Rest is in the middle.
          else {
            source.push(posName + " = " + argName + ".length - " + (minLen - i) + ";")
            if (isRestIdent) source.push("ret.push(" + argName + ".slice(" + i + ", " + posName + "));");
          }
        }
        // The current child is a non-rest pattern.
        else {
          source.push("var " + childArgName + " = " + argName + "[" + posName + "++];");
          source.push(compilePattern(childArgName, child));
        }
      });
    
      return source.join("\n");
    }
    
    function compileObject (argName, node) {
      return hasRest(node)
        ? compileObjectRest(argName, node)
        : compileObjectStrict(argName, node);
    }
    
    function compileObjectStrict (argName, node) {
      // Helper var names
      var keysName = argName + "_keys";
      var countName = argName + "_count";
      var iName = argName + "_i";
    
      // Used to generate a key lookup table
      var keys = node.children.map(function (child) {
        return child.value + ":1";
      });
    
      var source = [
        "if (!(" + argName + " instanceof Object)) return false;",
        "var " + keysName + " = {" + keys.join(",") + "};",
        "var " + countName + " = 0;",
        "for (var " + iName + " in " + argName + ") {",
          "if (!(" + keysName + ".hasOwnProperty(" + iName + "))) return false;",
          "else " + countName + " += 1;",
        "}",
        "if (" + countName + " !== " + node.children.length + ") return false;"
      ];
    
      node.children.forEach(function (child, i) {
        var childArgName = argName + "_" + i;
        // If the child is just a key, stash it.
        if (child.type === "key") {
          source.push("ret.push(" + argName + "[" + child.value + "]);");
        }
        // If the child is a keyValue, perform further compilation.
        else {
          source.push(
            "var " + childArgName + " = " + argName + "[" + child.value + "];",
            compilePattern(childArgName, child.children[0])
          );
        }
      });
    
      return source.join("\n");
    }
    
    function compileObjectRest (argName, node) {
      // Helper var names
      var keysName = argName + "_keys";
      var countName = argName + "_count";
      var restName = argName + "_rest";
      var iName = argName + "_i";
    
      var minLen = node.children.length - 1;
      var hasRestIdent = false;
      var keys = [];
    
      node.children.forEach(function (child) {
        if (child.type === "restIdentifier") hasRestIdent = true;
        else if (child.type !== "rest") keys.push(child.value + ":1");
      });
    
      var source = [
        "if (!(" + argName + " instanceof Object)) return false;",
        "var " + keysName + " = {" + keys.join(",") + "};",
        "var " + countName + " = 0;"
      ];
    
      if (hasRestIdent) source.push("var " + restName + " = {};");
      source.push("for (var " + iName + " in " + argName + ") {");
    
      // If there's a rest identifier, non-matching keys need to be stashed in a
      // secondary object.
      if (hasRestIdent) {
        source.push(
          "if (!(" + keysName + ".hasOwnProperty(" + iName + "))) " + restName + "[" + iName + "] = " + argName + "[" + iName + "];",
          "else " + countName + " += 1;"
        );
      } 
      // Just check that all supplied keys are there.
      else {
        source.push(
          "if (" + keysName + ".hasOwnProperty(" + iName + ")) " + countName + " += 1;"
        );
      }
    
      source.push(
        "}", 
        "if (" + countName + " !== " + minLen + ") return false;"
      );
    
      node.children.forEach(function (child, i) {
        var childArgName = argName + "_" + i;
        // If the child is just a key, stash it.
        if (child.type === "key") {
          source.push("ret.push(" + argName + "[" + child.value + "]);");
        }
        // If the child is a keyValue, perform further compilation.
        else if (child.type === "keyValue") {
          source.push(
            "var " + childArgName + " = " + argName + "[" + child.value + "];",
            compilePattern(childArgName, child.children[0])
          );
        }
        // If the child is a restIdentifier, stash the clone.
        else if (child.type === "restIdentifier") {
          source.push("ret.push(" + restName + ");")
        }
      });
    
      return source.join("\n");
    }
    
    function compileClassArray (argName, node) {
      var valsName = argName + "_vals";
      var source = [
        "if (!(" + argName + " instanceof Object)) return false;",
        compileClassName(argName, node),
        "if (!" + argName + ".constructor || !" + argName + ".constructor.unapply) return false;",
        "var " + valsName + " = " + argName + ".constructor.unapply(" + argName +");",
        compileArray(valsName, node)
      ];
      return source.join("\n");
    }
    
    function compileClassObject (argName, node) {
      var valsName = argName + "_vals";
      var source = [
        "if (!(" + argName + " instanceof Object)) return false;",
        compileClassName(argName, node),
        "if (!" + argName + ".constructor || !" + argName + ".constructor.unapplyObj) return false;",
        "var " + valsName + " = " + argName + ".constructor.unapplyObj(" + argName +");",
        compileObject(valsName, node)
      ];
      return source.join("\n");
    }
    return module.exports;
  })();

  require.modules['./runtime'] = (function () {
    var module = {exports: {}}, exports = module.exports;
    var toString = Object.prototype.toString;
    
    // Given an object and a class name, tries to determine if the object is an
    // instance of said class.
    function matchesTypeName (obj, name) {
      var typeStr = toString.call(obj);
      if (typeStr.substring(8, typeStr.length - 1) === name) {
        return true;
      }
    
      if (obj.constructor) {
        if (obj.constructor.name === name || obj.constructor.className === name) {
          return true;
        }
      }
    
      return false;
    }
    
    // Export
    exports.matchesTypeName = matchesTypeName;
    return module.exports;
  })();

  require.modules['./matcher'] = (function () {
    var module = {exports: {}}, exports = module.exports;
    var runtime = require("./runtime");
    
    // Matcher constructor that acts as a linked list of match alternatives.
    function Matcher (patternFn, successFn, next) {
      this.patternFn = patternFn;
      this.successFn = successFn;
      this.next = next;
    }
    
    // Export
    exports.Matcher = Matcher;
    
    // Tries to match a given array of args. If not successful, passes it on to
    // the `next` matcher.
    Matcher.prototype.match = function (args, context) {
      var args2 = this.patternFn(args, runtime);
      if (args2) return this.successFn.apply(context, args2);
      else if (this.next) return this.next.match(args, context);
      else throw new TypeError("All patterns exhausted");
    };
    
    // Clones itself and the next item in the list.
    Matcher.prototype.clone = function () {
      var clone = new Matcher(this.patternFn, this.successFn);
      if (this.next) clone.next = this.next.clone();
      return clone;
    };
    
    // Finds the last Matcher in the chain.
    Matcher.prototype.last = function () {
      var m = this;
      while (m.next) m = m.next;
      return m;
    };
    
    // Remove and return the last item off the chain.
    Matcher.prototype.pop = function () {
      var m = this, prev; 
      while (m.next) {
        prev = m;
        m = m.next;
      }
      if (prev) prev.next = null;
      return m;
    };
    return module.exports;
  })();

  require.modules['./matches'] = (function () {
    var module = {exports: {}}, exports = module.exports;
    var parser = require("./parser");
    var compiler = require("./compiler");
    var Matcher = require("./matcher").Matcher;
    
    // Cache slice
    var slice = Array.prototype.slice;
    
    // Internal cache of all patterns
    var patterns = {};
    
    // Internal cache of all unique, normalized patterns
    var normalized = {};
    
    // Creates a pattern matching function given a string and a fn to execute.
    function pattern () {
      var args = slice.call(arguments);
    
      // types
      var targ0 = typeof args[0];
      var targ1 = typeof args[1];
      var targ2 = typeof args[2];
    
      // Shared vars
      var matcherFn, patternObj, patternFn, patternStr, successFn, chain, tree, last;
    
      // pattern(matcherFn, chain)
      if (targ0 == "function" && (targ1 == "undefined" || targ1 == "object")) { 
        matcherFn = args[0];
        chain = args[1];
    
        // Throw an error if the supplied function does not have a match chain.
        if (!matcherFn.__matchChain) throw new Error("Not a matcher function");
    
        // Splice the chains together.
        if (chain) {
          chain = chain.clone();
          chain.last().next = matcherFn.__matchChain.clone();
        } else {
          chain = matcherFn.__matchChain.clone();
        }
    
        last = chain.pop();
        return matcher(last.patternFn, last.successFn, chain);
      }
    
      // pattern(patternObj, chain)
      else if (targ0 == "object" && (targ1 == "undefined" || targ1 == "object")) {
        patternObj = args[0];
        chain = args[1] ? args[1].clone() : null;
        for (patternStr in patternObj) {
          matcherFn = pattern(patternStr, patternObj[patternStr], chain);
          chain = matcherFn.__matchChain;
        }
        return matcherFn;
      }
    
      // pattern(patternFn, successFn, chain)
      else if (targ0 == "function" && targ1 == "function") {
        chain = args[2] ? args[2].clone() : null;
        return matcher(args[0], args[1], chain);
      }
    
      // pattern(patternStr, successFn, chain)
      else {
        patternStr = args[0];
        successFn = args[1];
        chain = args[2] ? args[2].clone() : null;
    
        // Check if we've already compiled the same patternStr before.
        if (patternStr in patterns) {
          patternFn = patterns[patternStr];
        }
    
        else {
          tree = parser.parse(patternStr);
    
          // Check if we've already compiled a pattern function for the normalized
          // pattern. If so, just use that and don't bother compiling.
          if (tree.pattern in normalized) {
            patternFn = (patterns[patternStr] = normalized[tree.pattern]);
          }
    
          // Compile the pattern function and cache it.
          else {
            patternFn = compiler.compile(tree);
            patternFn.pattern = tree.pattern;
            patterns[patternStr] = patternFn;
            normalized[tree.pattern] = patternFn;
          }
        }
    
        return matcher(patternFn, successFn, chain);
      }
    }
    
    // Creates a function that tries a match and executes the given fn if
    // successful. If not it tries subsequent patterns.
    function matcher (patternFn, successFn, chain) {
      var matcherObj = new Matcher(patternFn, successFn);
    
      if (chain) {
        chain.last().next = matcherObj;
      } else {
        chain = matcherObj;
      }
    
      var fn = function () {
        var args = slice.call(arguments);
        return chain.match(args, this);
      };
    
      fn.alt = function () {
        var args = slice.call(arguments);
        args.push(chain);
        return pattern.apply(null, args);
      }
    
      fn.__matchChain = chain;
    
      return fn;
    }
    
    // Sugar for creating a new pattern and immediately invoking it with arguments.
    // This just lets you put the arguments first instead of after the patterns.
    function caseOf (/* args..., matcher */) {
      var args = slice.call(arguments, 0, -1);
      var matcher = arguments[arguments.length - 1];
      var context = this === exports ? null : this;
    
      if (typeof matcher === "function") {
        // Throw an error if the supplied function does not have a match chain.
        if (!matcher.__matchChain) throw new Error("Not a matcher function");
        return matcher.apply(context, args);
      }
    
      return pattern(matcher).apply(context, args);
    }
    
    // Export
    exports.pattern = pattern;
    exports.caseOf = caseOf;
    exports.parser = parser;
    exports.compiler = compiler;
    return module.exports;
  })();

  window.matches = require('./matches');
})();
